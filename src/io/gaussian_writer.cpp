#include "gaussian_writer.h"
#include <iomanip>
#include <filesystem>
#include <sstream>
#include <algorithm>

namespace fakeg {
namespace io {

GaussianWriter::GaussianWriter() : programInfo("FakeG"), authorInfo("FakeG Project"), versionInfo("1.0") {}

GaussianWriter::GaussianWriter(const std::string& outputFilename) 
    : outputFilename(outputFilename), programInfo("FakeG"), authorInfo("FakeG Project"), versionInfo("1.0") {}

void GaussianWriter::setOutputFilename(const std::string& filename) {
    outputFilename = filename;
}

std::string GaussianWriter::getOutputFilename() const {
    return outputFilename;
}

void GaussianWriter::setProgramInfo(const std::string& program, const std::string& version, const std::string& author) {
    programInfo = program;
    versionInfo = version;
    authorInfo = author;
}

std::string GaussianWriter::generateOutputFilename(const std::string& inputFilename, const std::string& suffix) {
    size_t dotPos = inputFilename.find_last_of('.');
    if (dotPos != std::string::npos) {
        return inputFilename.substr(0, dotPos) + suffix + ".log";
    } else {
        return inputFilename + suffix + ".log";
    }
}

std::string GaussianWriter::formatEnergy(double energy, int precision) {
    std::ostringstream oss;
    oss << std::fixed << std::setprecision(precision) << energy;
    return oss.str();
}

std::string GaussianWriter::formatCoordinate(double coord, int precision) {
    std::ostringstream oss;
    oss << std::fixed << std::setprecision(precision) << std::setw(12) << coord;
    return oss.str();
}

std::string GaussianWriter::formatFrequency(double freq, int precision) {
    std::ostringstream oss;
    oss << std::fixed << std::setprecision(precision) << std::setw(12) << freq;
    return oss.str();
}

std::string GaussianWriter::formatIntensity(double intensity, int precision) {
    std::ostringstream oss;
    oss << std::fixed << std::setprecision(precision) << std::setw(12) << intensity;
    return oss.str();
}


bool GaussianWriter::writeGaussianOutput(const data::ParsedData& data) {
    return writeGaussianOutput(data, outputFilename);
}

bool GaussianWriter::writeGaussianOutput(const data::ParsedData& data, const std::string& filename) {
    std::ofstream out(filename);
    if (!out.is_open()) {
        return false;
    }
    
    writeHeader(out, data);
    
    for (size_t i = 0; i < data.optSteps.size(); i++) {
        const data::TDDFTData* tddftData = nullptr;
        if (data.hasTDDFT && i < data.tddftData.size() && data.tddftData[i].hasData) {
            tddftData = &data.tddftData[i];
        }
        writeOptimizationStep(out, data.optSteps[i], tddftData);
    }
    
    if (data.hasOpt) {
        out << std::endl << " Normal termination of Gaussian" << std::endl;
    }
    
    if (data.hasFreq && !data.frequencies.empty()) {
        writeFrequencies(out, data);
        out << std::endl << " Normal termination of Gaussian" << std::endl;
    }
    
    writeFooter(out);
    out.close();
    return true;
}

void GaussianWriter::writeHeader(std::ofstream& out, const data::ParsedData& data) {
    out << "! This file was generated by " << programInfo << " version " << versionInfo << std::endl;
    out << "! Author: " << authorInfo << std::endl;
    out << "! Converted quantum chemistry output to Gaussian format" << std::endl;
    out << std::endl;
    
    // 如果有charge和spin信息，输出它们
    if (data.hasChargeSpinInfo) {
        out << " Charge = " << std::setw(4) << data.charge 
            << " Multiplicity = " << data.spin << std::endl;
    }
    
    out << "0 basis functions" << std::endl;
    out << "0 alpha electrons" << std::endl;
    out << "0 beta electrons" << std::endl;
    out << "GradGradGradGradGradGradGradGradGradGradGradGradGradGradGradGradGradGrad" << std::endl;
    out << "GradGradGradGradGradGradGradGradGradGradGradGradGradGradGradGradGradGrad" << std::endl;
}

void GaussianWriter::writeOptimizationStep(std::ofstream& out, const data::OptStep& step, const data::TDDFTData* tddftData) {
    out << std::endl;
    out << "                        Standard orientation:" << std::endl;
    out << "---------------------------------------------------------------------" << std::endl;
    out << " Center     Atomic      Atomic             Coordinates (Angstroms)" << std::endl;
    out << " Number     Number       Type             X           Y           Z" << std::endl;
    out << "---------------------------------------------------------------------" << std::endl;
    
    for (size_t i = 0; i < step.atoms.size(); i++) {
        const auto& atom = step.atoms[i];
        out << std::setw(7) << (i + 1)
            << std::setw(11) << atom.atomicNumber
            << std::setw(12) << 0
            << "    "
            << std::fixed << std::setprecision(6)
            << std::setw(12) << atom.x
            << std::setw(12) << atom.y
            << std::setw(12) << atom.z << std::endl;
    }
    out << "---------------------------------------------------------------------" << std::endl;
    
    out << std::endl;
    out << " SCF Done:  E(theory) = " << formatEnergy(step.energy) << std::endl;
    
    // TDDFT数据紧跟在SCF Done后面
    if (tddftData && tddftData->hasData) {
        writeTDDFTData(out, *tddftData);
    }
    
    if (step.stepNumber > 0) {
        out << std::endl;
        out << " GradGradGradGradGradGradGradGradGradGradGradGradGradGradGradGradGradGrad" << std::endl;
        out << " Step number" << std::setw(4) << step.stepNumber << std::endl;
        out << "         Item               Value     Threshold  Converged?" << std::endl;
        
        double tolRMSG = 3.0e-4, tolMAXG = 4.5e-4, tolRMSD = 1.2e-3, tolMAXD = 1.8e-3;
        
        out << " Maximum Force       " << std::fixed << std::setprecision(6)
            << std::setw(13) << step.maxGrad 
            << std::setw(13) << tolMAXG << "     "
            << (step.maxGrad < tolMAXG ? "YES" : "NO") << std::endl;
        out << " RMS     Force       " 
            << std::setw(13) << step.rmsGrad 
            << std::setw(13) << tolRMSG << "     "
            << (step.rmsGrad < tolRMSG ? "YES" : "NO") << std::endl;
        out << " Maximum Displacement" 
            << std::setw(13) << step.maxStep 
            << std::setw(13) << tolMAXD << "     "
            << (step.maxStep < tolMAXD ? "YES" : "NO") << std::endl;
        out << " RMS     Displacement" 
            << std::setw(13) << step.rmsStep 
            << std::setw(13) << tolRMSD << "     "
            << (step.rmsStep < tolRMSD ? "YES" : "NO") << std::endl;
        out << " GradGradGradGradGradGradGradGradGradGradGradGradGradGradGradGradGradGrad" << std::endl;
    }
}

void GaussianWriter::writeFrequencies(std::ofstream& out, const data::ParsedData& data) {
    out << std::endl;
    out << " Harmonic frequencies (cm**-1), IR intensities (KM/Mole), Raman scattering" << std::endl;
    out << " activities (A**4/AMU), depolarization ratios for plane and unpolarized" << std::endl;
    out << " incident light, reduced masses (AMU), force constants (mDyne/A)," << std::endl;
    out << " and normal coordinates:" << std::endl;
    
    int nFreqs = data.frequencies.size();
    int nFrames = (nFreqs + 2) / 3;
    
    for (int iframe = 0; iframe < nFrames; iframe++) {
        int istart = iframe * 3;
        int iend = std::min(istart + 3, nFreqs);
        writeFrequencyBlock(out, data, istart, iend);
    }
    
    if (data.thermoData.hasData) {
        writeThermoData(out, data.thermoData);
    }
}

void GaussianWriter::writeFrequencyBlock(std::ofstream& out, const data::ParsedData& data, int startIdx, int endIdx) {
    int nAtoms = data.optSteps.empty() ? 0 : data.optSteps.back().atoms.size();
    
    for (int i = startIdx; i < endIdx; i++) {
        out << std::setw(23) << (i + 1);
    }
    out << std::endl;
    
    for (int i = startIdx; i < endIdx; i++) {
        out << std::setw(22) << "" << data.frequencies[i].irrep;
    }
    out << std::endl;
    
    for (int icol = 0; icol < (endIdx - startIdx); icol++) {
        int i = startIdx + icol;
        if (icol == 0) {
            out << " Frequencies --" << formatFrequency(data.frequencies[i].frequency);
        } else {
            out << std::setw(11) << "" << formatFrequency(data.frequencies[i].frequency);
        }
    }
    out << std::endl;
    
    for (int icol = 0; icol < (endIdx - startIdx); icol++) {
        int i = startIdx + icol;
        if (icol == 0) {
            out << " IR Inten    --" << formatIntensity(data.frequencies[i].irIntensity);
        } else {
            out << std::setw(11) << "" << formatIntensity(data.frequencies[i].irIntensity);
        }
    }
    out << std::endl;
    
    for (int icol = 0; icol < (endIdx - startIdx); icol++) {
        if (icol == 0) {
            out << "  Atom  AN      X      Y      Z  ";
        } else {
            out << "      X      Y      Z  ";
        }
    }
    out << std::endl;
    
    for (int iatom = 0; iatom < nAtoms; iatom++) {
        if (!data.optSteps.empty()) {
            int atomicNumber = data.optSteps.back().atoms[iatom].atomicNumber;
            
            for (int icol = 0; icol < (endIdx - startIdx); icol++) {
                int i = startIdx + icol;
                if (icol == 0) {
                    out << std::setw(6) << (iatom + 1) << std::setw(4) << atomicNumber << "  ";
                    if (static_cast<size_t>(i) < data.frequencies.size() && 
                        static_cast<size_t>(iatom) < data.frequencies[i].displacements.size() &&
                        data.frequencies[i].displacements[iatom].size() >= 3) {
                        out << std::fixed << std::setprecision(2)
                            << std::setw(7) << data.frequencies[i].displacements[iatom][0]
                            << std::setw(7) << data.frequencies[i].displacements[iatom][1]
                            << std::setw(7) << data.frequencies[i].displacements[iatom][2];
                    } else {
                        out << "   0.00   0.00   0.00";
                    }
                } else {
                    out << "  ";
                    if (static_cast<size_t>(i) < data.frequencies.size() && 
                        static_cast<size_t>(iatom) < data.frequencies[i].displacements.size() &&
                        data.frequencies[i].displacements[iatom].size() >= 3) {
                        out << std::fixed << std::setprecision(2)
                            << std::setw(7) << data.frequencies[i].displacements[iatom][0]
                            << std::setw(7) << data.frequencies[i].displacements[iatom][1]
                            << std::setw(7) << data.frequencies[i].displacements[iatom][2];
                    } else {
                        out << "   0.00   0.00   0.00";
                    }
                }
            }
            out << std::endl;
        }
    }
}

void GaussianWriter::writeThermoData(std::ofstream& out, const data::ThermoData& thermoData) {
    out << std::endl;
    out << " Temperature" << std::fixed << std::setprecision(3) << std::setw(10) << thermoData.temperature 
        << " Kelvin.  Pressure" << std::setprecision(5) << std::setw(10) << thermoData.pressure << " Atm." << std::endl;
    out << " Zero-point correction=                           " << std::setprecision(6) << std::setw(8) << thermoData.zpe << " Hartree" << std::endl;
    out << " Thermal correction to Energy=                    " << std::setprecision(6) << std::setw(8) << thermoData.thermalEnergyCorr << std::endl;
    out << " Thermal correction to Enthalpy=                  " << std::setprecision(6) << std::setw(8) << thermoData.thermalEnthalpyCorr << std::endl;
    out << " Thermal correction to Gibbs Free Energy=        " << std::setprecision(6) << std::setw(8) << thermoData.thermalGibbsCorr << std::endl;
    out << " Electronic energy=                          " << std::setprecision(6) << std::setw(20) << thermoData.electronicEnergy << std::endl;
    out << " Sum of electronic and zero-point Energies=  " << std::setprecision(6) << std::setw(20) << (thermoData.electronicEnergy + thermoData.zpe) << std::endl;
    out << " Sum of electronic and thermal Energies=     " << std::setprecision(6) << std::setw(20) << (thermoData.electronicEnergy + thermoData.thermalEnergyCorr) << std::endl;
    out << " Sum of electronic and thermal Enthalpies=   " << std::setprecision(6) << std::setw(20) << (thermoData.electronicEnergy + thermoData.thermalEnthalpyCorr) << std::endl;
    out << " Sum of electronic and thermal Free Energies=" << std::setprecision(6) << std::setw(20) << (thermoData.electronicEnergy + thermoData.thermalGibbsCorr) << std::endl;
}

void GaussianWriter::writeConvergenceData(std::ofstream& out, const data::ThermoData& thermoData) {
    out << std::endl;
    out << " Convergence of gradients" << std::endl;
    out << "                                  Value     Tolerance      Converged?" << std::endl;
    
    out << "  Maximum Delta-X          " << std::fixed << std::setprecision(6) << std::setw(12) << thermoData.maxDeltaX
        << std::setw(13) << "0.004000" << "            " 
        << (thermoData.maxDeltaX < 0.004000 ? "Yes" : "No") << std::endl;
    
    out << "      RMS Delta-X          " << std::setw(12) << thermoData.rmsDeltaX
        << std::setw(13) << "0.002500" << "            "
        << (thermoData.rmsDeltaX < 0.002500 ? "Yes" : "No") << std::endl;
    
    out << "    Maximum Force          " << std::setw(12) << thermoData.maxForce
        << std::setw(13) << "0.000800" << "            "
        << (thermoData.maxForce < 0.000800 ? "Yes" : "No") << std::endl;
    
    out << "        RMS Force          " << std::setw(12) << thermoData.rmsForce
        << std::setw(13) << "0.000500" << "            "
        << (thermoData.rmsForce < 0.000500 ? "Yes" : "No") << std::endl;
    
    out << " Expected Delta-E          " << std::scientific << std::setprecision(2) << std::setw(12) << thermoData.expectedDeltaE
        << std::setw(13) << "0.50E-05" << "            "
        << (thermoData.expectedDeltaE < 0.50e-05 ? "Yes" : "No") << std::endl;
}

void GaussianWriter::writeFooter(std::ofstream& out) {
    (void)out; // 抑制未使用参数警告
    // 当前不需要特殊的文件尾
}

bool GaussianWriter::validateOutput(const std::string& filename) {
    std::ifstream file(filename);
    if (!file.is_open()) {
        return false;
    }
    
    std::string line;
    bool hasHeader = false;
    bool hasGeometry = false;
    
    while (std::getline(file, line)) {
        if (line.find("This file was generated by") != std::string::npos) {
            hasHeader = true;
        }
        if (line.find("Standard orientation:") != std::string::npos) {
            hasGeometry = true;
        }
    }
    
    return hasHeader && hasGeometry;
}

void GaussianWriter::writeTDDFTData(std::ofstream& out, const data::TDDFTData& tddftData) {
    if (!tddftData.hasData || tddftData.excitedStates.empty()) {
        return;
    }
    
    out << std::endl;
    out << " Excitation energies and oscillator strengths:" << std::endl;
    out << std::endl;
    
    for (const auto& excitedState : tddftData.excitedStates) {
        writeExcitedState(out, excitedState);
    }
    
    // 添加激发态块结束语句
    out << " SavETr:  write IOETrn=     0 NScale=  0 NData=   0 NLR=  NState=    0 LETran=       0." << std::endl;
}

void GaussianWriter::writeExcitedState(std::ofstream& out, const data::ExcitedState& excitedState) {
    // 输出激发态标题行
    out << " Excited State" << std::setw(4) << excitedState.stateNumber << ":      "
        << std::setw(10) << std::left << excitedState.symmetry << std::right
        << std::fixed << std::setprecision(4) << std::setw(8) << excitedState.excitationEnergy_eV
        << " eV" << std::setw(8) << std::setprecision(2) << excitedState.wavelength_nm
        << " nm  f=" << std::setprecision(4) << std::setw(6) << excitedState.oscillatorStrength
        << "  <S**2>=" << std::setprecision(3) << excitedState.s2Value << std::endl;
    
    // 输出轨道跃迁信息
    writeOrbitalTransitions(out, excitedState.transitions);
    
    // 如果有优化相关信息
    if (excitedState.hasOptimizationInfo) {
        out << " This state for optimization and/or second-order correction." << std::endl;
    }
    
    // 如果有总能量信息
    if (excitedState.hasTotalEnergy) {
        out << " Total Energy, E(TD-HF/TD-DFT) = " << std::fixed << std::setprecision(10)
            << std::setw(15) << excitedState.totalEnergy << "    " << std::endl;
    }
    
    // 输出额外信息
    if (!excitedState.additionalInfo.empty()) {
        out << " " << excitedState.additionalInfo << std::endl;
    }
    
    out << std::endl;
}

void GaussianWriter::writeOrbitalTransitions(std::ofstream& out, const std::vector<data::OrbitalTransition>& transitions) {
    for (const auto& transition : transitions) {
        out << "      " << std::setw(2) << transition.fromOrb;
        
        // 根据原始箭头方向输出：--> 转为 ->，<-- 转为 <-
        if (transition.isForward) {
            out << " -> " << std::setw(2) << transition.toOrb;
        } else {
            out << " <- " << std::setw(2) << transition.toOrb;
        }
        
        out << "         " << std::fixed << std::setprecision(5) 
            << transition.coefficient << std::endl;
    }
}


} // namespace io
} // namespace fakeg 