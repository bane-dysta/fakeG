#include "xtb_parser.h"
#include "../logger/logger.h"
#include <algorithm>
#include <iomanip>

namespace fakeg {
namespace parsers {

XtbParser::XtbParser() : xtbFormatDetected(false) {}

bool XtbParser::parse(io::FileReader& reader, data::ParsedData& data) {
    std::ifstream& file = reader.getStream();
    
    infoLog("Starting XTB Gaussian format file parsing");
    
    // 重置文件位置
    string_utils::LineProcessor::resetToBeginning(file);
    xtbFormatDetected = false;
    
    // 解析标准定向坐标
    if (!parseStandardOrientation(file, data)) {
        errorLog("Failed to parse standard orientation");
        return false;
    }
    
    // 解析频率信息
    if (!parseFrequencies(file, data)) {
        errorLog("Failed to parse frequencies");
        return false;
    }
    
    // 设置数据标志
    data.hasFreq = !data.frequencies.empty();
    data.hasOpt = false; // XTB频率输出通常不是优化轨迹
    
    // 设置默认热力学数据（温度和压力信息对gview识别很重要）
    data.thermoData.hasData = true;
    data.thermoData.temperature = 298.15; // 标准温度 (K)
    data.thermoData.pressure = 1.0;       // 标准压力 (atm)
    debugLog("Set default thermodynamic data: T=298.15K, P=1.0atm");
    
    if (xtbFormatDetected) {
        infoLog(">> Detected XTB Gaussian format output - frequency information available");
    }
    
    infoLog("XTB Gaussian format parsing completed");
    return true;
}

bool XtbParser::validateInput(const std::string& filename) {
    std::ifstream file(filename);
    if (!file.is_open()) {
        errorLog("Cannot open file: " + filename);
        return false;
    }
    
    // 用户指定的文件就是想要转换的文件，不需要额外验证
    (void)filename; // 抑制未使用参数警告
    return true;
}

std::string XtbParser::getParserName() const {
    return "XtbParser";
}

std::string XtbParser::getParserVersion() const {
    return "1.0.0";
}

std::vector<std::string> XtbParser::getSupportedKeywords() const {
    return {"XTB", "GAUSSIAN", "FREQUENCY", "G98"};
}

bool XtbParser::parseStandardOrientation(std::ifstream& file, data::ParsedData& data) {
    string_utils::LineProcessor::resetToBeginning(file);
    std::string line;
    
    // 查找标准定向表
    while (std::getline(file, line)) {
        if (line.find("Standard orientation:") != std::string::npos) {
            debugLog("Found standard orientation section");
            break;
        }
        
        // 检测XTB格式标识
        if (line.find("frequency output generated by the xtb code") != std::string::npos) {
            xtbFormatDetected = true;
            debugLog("Detected XTB format identifier");
        }
    }
    
    // 跳过表头（分割线、列标题1、列标题2、分割线）
    for (int i = 0; i < 4; i++) {
        if (!std::getline(file, line)) {
            errorLog("Unexpected end of file while reading orientation header");
            return false;
        }
        debugLog("Header line " + std::to_string(i+1) + ": " + line);
    }
    
    // 创建优化步骤
    data::OptStep step;
    step.stepNumber = 1;
    step.energy = -100.0; // 默认能量
    step.converged = true; // XTB频率计算默认收敛
    
    // 读取原子坐标
    while (std::getline(file, line)) {
        line = string_utils::trim(line);
        
        // 遇到分割线结束
        if (line.find("----") != std::string::npos) {
            debugLog("Found end of coordinates section");
            break;
        }
        
        // 跳过空行
        if (line.empty()) {
            continue;
        }
        
        // 解析原子行
        std::istringstream iss(line);
        int centerNum, atomicNum, atomType;
        double x, y, z;
        
        if (iss >> centerNum >> atomicNum >> atomType >> x >> y >> z) {
            data::Atom atom;
            atom.atomicNumber = atomicNum;
            atom.x = x;
            atom.y = y;
            atom.z = z;
            
            // 通过ElementMap获取元素符号
            if (elementMap) {
                // 这里需要反向查找，从原子序数获取符号
                // 简化处理，直接根据原子序数设置符号
                switch (atomicNum) {
                    case 1: atom.symbol = "H"; break;
                    case 6: atom.symbol = "C"; break;
                    case 7: atom.symbol = "N"; break;
                    case 8: atom.symbol = "O"; break;
                    case 9: atom.symbol = "F"; break;
                    case 15: atom.symbol = "P"; break;
                    case 16: atom.symbol = "S"; break;
                    case 17: atom.symbol = "Cl"; break;
                    default: atom.symbol = "X"; break;
                }
            } else {
                atom.symbol = "C"; // 默认为碳
            }
            
            step.atoms.push_back(atom);
            debugLog("Parsed atom: " + atom.symbol + " (" + std::to_string(atomicNum) + ") " +
                     std::to_string(x) + " " + std::to_string(y) + " " + std::to_string(z));
        } else {
            debugLog("Could not parse line: " + line);
        }
    }
    
    if (!step.atoms.empty()) {
        data.optSteps.push_back(step);
        infoLog("Found " + std::to_string(step.atoms.size()) + " atoms in standard orientation");
        return true;
    } else {
        errorLog("No atoms found in standard orientation");
        return false;
    }
}

bool XtbParser::parseFrequencies(std::ifstream& file, data::ParsedData& data) {
    string_utils::LineProcessor::resetToBeginning(file);
    std::string line;
    
    // 查找频率部分
    while (std::getline(file, line)) {
        if (line.find("Harmonic frequencies") != std::string::npos) {
            debugLog("Found frequency section");
            break;
        }
    }
    
    // 跳过描述行
    for (int i = 0; i < 2; i++) {
        if (!std::getline(file, line)) {
            errorLog("Unexpected end of file while reading frequency header");
            return false;
        }
    }
    
    // 解析频率块
    while (std::getline(file, line)) {
        line = string_utils::trim(line);
        
        if (line.empty()) {
            break;
        }
        
        // 查找频率编号行
        if (line.find_first_of("123456789") == 0) {
            // 解析频率编号
            std::istringstream iss(line);
            std::vector<int> freqIndices;
            int index;
            while (iss >> index) {
                freqIndices.push_back(index - 1); // 转为0基索引
            }
            
            if (!freqIndices.empty()) {
                debugLog("Found " + std::to_string(freqIndices.size()) + " frequency modes");
                parseFrequencyBlock(file, data.frequencies, freqIndices);
            }
        }
    }
    
    infoLog("Found " + std::to_string(data.frequencies.size()) + " frequency modes");
    return !data.frequencies.empty();
}

bool XtbParser::parseFrequencyBlock(std::ifstream& file, std::vector<data::FreqMode>& frequencies, 
                                  const std::vector<int>& freqIndices) {
    std::string line;
    
    // 确保频率向量足够大
    while (frequencies.size() <= static_cast<size_t>(*std::max_element(freqIndices.begin(), freqIndices.end()))) {
        frequencies.emplace_back();
    }
    
    // 跳过对称性行
    if (!std::getline(file, line)) return false;
    
    // 读取频率值
    if (std::getline(file, line) && line.find("Frequencies") != std::string::npos) {
        std::istringstream iss(line.substr(line.find("--") + 2));
        for (size_t i = 0; i < freqIndices.size(); i++) {
            double freq;
            if (iss >> freq) {
                frequencies[freqIndices[i]].frequency = freq;
                debugLog("Frequency " + std::to_string(freqIndices[i] + 1) + ": " + std::to_string(freq));
            }
        }
    }
    
    // 读取约化质量（FreqMode结构体中没有此字段，跳过）
    if (std::getline(file, line) && line.find("Red. masses") != std::string::npos) {
        // 跳过约化质量数据，因为FreqMode结构体中没有此字段
        debugLog("Skipping reduced masses (not stored in FreqMode)");
    }
    
    // 跳过力常数行
    if (!std::getline(file, line)) return false;
    
    // 读取IR强度
    if (std::getline(file, line) && line.find("IR Inten") != std::string::npos) {
        std::istringstream iss(line.substr(line.find("--") + 2));
        for (size_t i = 0; i < freqIndices.size(); i++) {
            double intensity;
            if (iss >> intensity) {
                frequencies[freqIndices[i]].irIntensity = intensity;
            }
        }
    }
    
    // 跳过Raman和Depolar行
    std::getline(file, line); // Raman Activ
    std::getline(file, line); // Depolar
    
    // 读取原子位移
    debugLog("Starting to read atom displacements");
    while (std::getline(file, line)) {
        line = string_utils::trim(line);
        debugLog("Reading displacement line: '" + line + "'");
        
        if (line.empty()) {
            // 遇到空行
            debugLog("Found empty line, ending displacement block");
            break;
        }
        
        // 检查是否是下一个频率块的开始（纯数字行，如"4 5 6"）
        std::istringstream testIss(line);
        std::string firstWord;
        testIss >> firstWord;
        if (firstWord.find_first_not_of("0123456789") == std::string::npos && 
            firstWord.length() < 3 && std::stoi(firstWord) > 3) {
            // 如果是纯数字且可能是频率编号
            debugLog("Found next frequency block, ending displacement block");
            file.seekg(-static_cast<int>(line.length() + 1), std::ios::cur);
            break;
        }
        
        if (line.find("Atom") != std::string::npos) {
            debugLog("Skipping atom header line");
            continue; // 跳过表头
        }
        
        // 解析原子位移
        std::istringstream iss(line);
        int atomNum, atomicNum;
        if (iss >> atomNum >> atomicNum) {
            debugLog("Parsing displacements for atom " + std::to_string(atomNum));
            parseAtomDisplacements(line, atomNum - 1, frequencies, freqIndices);
        } else {
            debugLog("Could not parse atom line: " + line);
        }
    }
    
    return true;
}

void XtbParser::parseAtomDisplacements(const std::string& line, int atomIndex, 
                                     std::vector<data::FreqMode>& frequencies, 
                                     const std::vector<int>& freqIndices) {
    std::istringstream iss(line);
    int atomNum, atomicNum;
    iss >> atomNum >> atomicNum; // 跳过原子编号和原子序数
    
    debugLog("Parsing displacements for atom " + std::to_string(atomIndex + 1) + ", line: " + line);
    
    // 为每个频率读取三个分量(x,y,z)
    for (size_t i = 0; i < freqIndices.size(); i++) {
        double x, y, z;
        if (iss >> x >> y >> z) {
            int freqIdx = freqIndices[i];
            
            // 确保位移向量足够大
            while (frequencies[freqIdx].displacements.size() <= static_cast<size_t>(atomIndex)) {
                frequencies[freqIdx].displacements.emplace_back(3, 0.0);
            }
            
            frequencies[freqIdx].displacements[atomIndex][0] = x;
            frequencies[freqIdx].displacements[atomIndex][1] = y;
            frequencies[freqIdx].displacements[atomIndex][2] = z;
            
            debugLog("Atom " + std::to_string(atomIndex + 1) + " freq " + std::to_string(freqIdx + 1) + 
                     " displacement: " + std::to_string(x) + " " + std::to_string(y) + " " + std::to_string(z));
        } else {
            debugLog("Failed to read displacement for freq " + std::to_string(freqIndices[i] + 1));
            break;
        }
    }
}

} // namespace parsers
} // namespace fakeg 