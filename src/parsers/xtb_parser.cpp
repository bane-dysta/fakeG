#include "xtb_parser.h"
#include "../logger/logger.h"
#include <algorithm>
#include <iomanip>

namespace fakeg {
namespace parsers {

XtbParser::XtbParser() : xtbFormatDetected(false) {}

bool XtbParser::parse(io::FileReader& reader, data::ParsedData& data) {
    std::ifstream& file = reader.getStream();
    
    infoLog("Starting XTB Gaussian format file parsing");
    
    // 重置文件位置
    string_utils::LineProcessor::resetToBeginning(file);
    xtbFormatDetected = false;
    
    // 解析标准定向坐标
    if (!parseStandardOrientation(file, data)) {
        errorLog("Failed to parse standard orientation");
        return false;
    }
    
    // 解析频率信息
    if (!parseFrequencies(file, data)) {
        errorLog("Failed to parse frequencies");
        return false;
    }
    
    // 设置数据标志
    data.hasFreq = !data.frequencies.empty();
    data.hasOpt = false; // XTB频率输出通常不是优化轨迹
    
    // 设置默认热力学数据（温度和压力信息对gview识别很重要）
    data.thermoData.hasData = true;
    data.thermoData.temperature = 298.15; // 标准温度 (K)
    data.thermoData.pressure = 1.0;       // 标准压力 (atm)
    debugLog("Set default thermodynamic data: T=298.15K, P=1.0atm");
    
    if (xtbFormatDetected) {
        infoLog(">> Detected XTB Gaussian format output - frequency information available");
    }
    
    infoLog("XTB Gaussian format parsing completed");
    return true;
}

bool XtbParser::validateInput(const std::string& filename) {
    std::ifstream file(filename);
    if (!file.is_open()) {
        errorLog("Cannot open file: " + filename);
        return false;
    }
    
    // 用户指定的文件就是想要转换的文件，不需要额外验证
    (void)filename; // 抑制未使用参数警告
    return true;
}

std::string XtbParser::getParserName() const {
    return "XtbParser";
}

std::string XtbParser::getParserVersion() const {
    return "1.0.0";
}

std::vector<std::string> XtbParser::getSupportedKeywords() const {
    return {"XTB", "GAUSSIAN", "FREQUENCY", "G98"};
}

bool XtbParser::parseStandardOrientation(std::ifstream& file, data::ParsedData& data) {
    string_utils::LineProcessor::resetToBeginning(file);
    std::string line;
    
    // 查找标准定向表
    while (std::getline(file, line)) {
        if (line.find("Standard orientation:") != std::string::npos) {
            debugLog("Found standard orientation section");
            break;
        }
        
        // 检测XTB格式标识
        if (line.find("frequency output generated by the xtb code") != std::string::npos) {
            xtbFormatDetected = true;
            debugLog("Detected XTB format identifier");
        }
    }
    
    // 跳过表头（分割线、列标题1、列标题2、分割线）
    for (int i = 0; i < 4; i++) {
        if (!std::getline(file, line)) {
            errorLog("Unexpected end of file while reading orientation header");
            return false;
        }
        debugLog("Header line " + std::to_string(i+1) + ": " + line);
    }
    
    // 创建优化步骤
    data::OptStep step;
    step.stepNumber = 1;
    step.energy = -100.0; // 默认能量
    step.converged = true; // XTB频率计算默认收敛
    
    // 读取原子坐标
    while (std::getline(file, line)) {
        line = string_utils::trim(line);
        
        // 遇到分割线结束
        if (line.find("----") != std::string::npos) {
            debugLog("Found end of coordinates section");
            break;
        }
        
        // 跳过空行
        if (line.empty()) {
            continue;
        }
        
        // 解析原子行
        std::istringstream iss(line);
        int centerNum, atomicNum, atomType;
        double x, y, z;
        
        if (iss >> centerNum >> atomicNum >> atomType >> x >> y >> z) {
            data::Atom atom;
            atom.atomicNumber = atomicNum;
            atom.x = x;
            atom.y = y;
            atom.z = z;
            
            // 通过ElementMap获取元素符号
            if (elementMap) {
                // 这里需要反向查找，从原子序数获取符号
                // 简化处理，直接根据原子序数设置符号
                switch (atomicNum) {
                    case 1: atom.symbol = "H"; break;
                    case 6: atom.symbol = "C"; break;
                    case 7: atom.symbol = "N"; break;
                    case 8: atom.symbol = "O"; break;
                    case 9: atom.symbol = "F"; break;
                    case 15: atom.symbol = "P"; break;
                    case 16: atom.symbol = "S"; break;
                    case 17: atom.symbol = "Cl"; break;
                    default: atom.symbol = "X"; break;
                }
            } else {
                atom.symbol = "C"; // 默认为碳
            }
            
            step.atoms.push_back(atom);
            debugLog("Parsed atom: " + atom.symbol + " (" + std::to_string(atomicNum) + ") " +
                     std::to_string(x) + " " + std::to_string(y) + " " + std::to_string(z));
        } else {
            debugLog("Could not parse line: " + line);
        }
    }
    
    if (!step.atoms.empty()) {
        data.optSteps.push_back(step);
        infoLog("Found " + std::to_string(step.atoms.size()) + " atoms in standard orientation");
        return true;
    } else {
        errorLog("No atoms found in standard orientation");
        return false;
    }
}

bool XtbParser::parseFrequencies(std::ifstream& file, data::ParsedData& data) {
    string_utils::LineProcessor::resetToBeginning(file);
    std::string line;
    
    // 查找频率部分
    while (std::getline(file, line)) {
        if (line.find("Harmonic frequencies") != std::string::npos) {
            debugLog("Found frequency section");
            break;
        }
    }
    
    // 跳过描述行
    for (int i = 0; i < 2; i++) {
        if (!std::getline(file, line)) {
            errorLog("Unexpected end of file while reading frequency header");
            return false;
        }
    }
    
    // 逐行解析所有内容
    std::vector<int> currentFreqIndices;
    bool inFreqBlock = false;
    
    while (std::getline(file, line)) {
        line = string_utils::trim(line);
        
        if (line.empty()) {
            break;
        }
        
        // 检查是否是频率编号行
        std::istringstream iss(line);
        std::vector<int> numbers;
        std::string word;
        bool isFreqLine = true;
        
        while (iss >> word) {
            try {
                int num = std::stoi(word);
                numbers.push_back(num);
            } catch (...) {
                isFreqLine = false;
                break;
            }
        }
        
        if (isFreqLine && numbers.size() >= 1 && numbers.size() <= 3) {
            // 这是频率编号行
            currentFreqIndices = numbers;
            debugLog("Found frequencies: " + line);
            inFreqBlock = true;
            
            // 确保频率向量足够大
            for (int idx : currentFreqIndices) {
                while (data.frequencies.size() <= static_cast<size_t>(idx - 1)) {
                    data.frequencies.emplace_back();
                }
            }
            continue;
        }
        
        if (!inFreqBlock) continue;
        
        // 跳过对称性行
        if (line.find_first_not_of("a ") == std::string::npos) {
            continue;
        }
        
        // 解析频率值
        if (line.find("Frequencies") != std::string::npos) {
            std::istringstream freqIss(line.substr(line.find("--") + 2));
            for (size_t i = 0; i < currentFreqIndices.size(); i++) {
                double freq;
                if (freqIss >> freq) {
                    int idx = currentFreqIndices[i] - 1;
                    data.frequencies[idx].frequency = freq;
                    debugLog("Frequency " + std::to_string(currentFreqIndices[i]) + ": " + std::to_string(freq));
                }
            }
            continue;
        }
        
        // 跳过其他属性行
        if (line.find("Red. masses") != std::string::npos ||
            line.find("Frc consts") != std::string::npos ||
            line.find("Raman Activ") != std::string::npos ||
            line.find("Depolar") != std::string::npos) {
            continue;
        }
        
        // 解析IR强度
        if (line.find("IR Inten") != std::string::npos) {
            std::istringstream irIss(line.substr(line.find("--") + 2));
            for (size_t i = 0; i < currentFreqIndices.size(); i++) {
                double intensity;
                if (irIss >> intensity) {
                    int idx = currentFreqIndices[i] - 1;
                    data.frequencies[idx].irIntensity = intensity;
                }
            }
            continue;
        }
        
        // 跳过原子表头
        if (line.find("Atom AN") != std::string::npos) {
            continue;
        }
        
        // 解析原子位移
        std::istringstream atomIss(line);
        int atomNum, atomicNum;
        if (atomIss >> atomNum >> atomicNum) {
            for (size_t i = 0; i < currentFreqIndices.size(); i++) {
                double x, y, z;
                if (atomIss >> x >> y >> z) {
                    int freqIdx = currentFreqIndices[i] - 1;
                    int atomIdx = atomNum - 1;
                    
                    // 确保位移向量足够大
                    while (data.frequencies[freqIdx].displacements.size() <= static_cast<size_t>(atomIdx)) {
                        data.frequencies[freqIdx].displacements.emplace_back(3, 0.0);
                    }
                    
                    data.frequencies[freqIdx].displacements[atomIdx][0] = x;
                    data.frequencies[freqIdx].displacements[atomIdx][1] = y;
                    data.frequencies[freqIdx].displacements[atomIdx][2] = z;
                }
            }
        }
    }
    
    infoLog("Found " + std::to_string(data.frequencies.size()) + " frequency modes");
    return !data.frequencies.empty();
}

} // namespace parsers
} // namespace fakeg 